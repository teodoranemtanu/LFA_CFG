#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <map>
#include <queue>
#include <algorithm>

using namespace std;
ifstream fin("..\\date.in");
ofstream fout("..\\date.out");
const int nmax = 1000;

string word;
int nrTerminals, nrNonterminals;
vector<char> nonterminals;
vector<char> terminals;
map<char, vector<string> > productions;
int nrProductions;
///A -> AA / aBa / lambda(codified with #)
char start;

void readGrammar() {
    fin >> nrTerminals;
    terminals.resize(nrTerminals);
    for (int i = 0; i < nrTerminals; i++)
        fin >> terminals[i];
    fin >> nrNonterminals;
    nonterminals.resize(nrNonterminals);
    for (int i = 0; i < nrNonterminals; i++)
        fin >> nonterminals[i];
    fin >> nrProductions;
    for (int i = 0; i < nrProductions; i++) {
        char leftMember;
        string rightMember;
        fin >> leftMember >> rightMember;
        productions[leftMember].push_back(rightMember);
    }
    fin >> start;
}

/**
 *
 * @param production - the production in which a next nonterminal is being searched for
 * @return iterator to the first nonterminal found in the production
 * nonterminals.end() otherwise
 */
int findNonterminal(string production) {
    for (int i = 0; i < production.size(); i++) {
        auto it = find(nonterminals.begin(), nonterminals.end(), production[i]);
        if (it != nonterminals.end()) return i;
    }
    return -1;
}

/**
 *
 * @param word - word to be tested whether it can be generated by the current CIG
 * @return true if generated, false otherwise
 */
bool isGenerated(string word) {
    queue<string> futureWords;
    // marks all the productions that can be realized from the start nonterminal as future words
    for (auto i : productions[start])
        futureWords.push(i);
    //while we still have productions to test
    while (!futureWords.empty()) {
        string currentWord = futureWords.front();
        futureWords.pop();
        // searches for a nonterminal in the current word
        int nonTerminalPosition = findNonterminal(currentWord);
        if (nonTerminalPosition >= 0) {
            // if a nonterminal has been found, we try to replace it with its productions
            char currentNonterminal = currentWord[nonTerminalPosition];
            for (auto i : productions[currentNonterminal]) {
                string newWord;
                char aux[nmax];
                newWord.append(currentWord.begin(), currentWord.begin() + nonTerminalPosition);
                if (i != "#") newWord.append(i);
                newWord.append(currentWord.begin() + nonTerminalPosition + 1, currentWord.end());
                /// we stop when a new word found is either bigger than the initial word or equal to the it
                if (newWord.size() <= word.size() + 1)
                    futureWords.push(newWord);
                if (newWord == word)
                    return true;
            }
        }
    }
    return false;
}

int main() {
    cin >> word;
    readGrammar();
    if (isGenerated(word)) {
        cout << "Cuvantul e generat de gramatica.";
    } else {
        cout << "Cuvantul nu e generat de gramatica.";
    }

    return 0;
}